// main.cpp version for full demo

#include <cmath>
#include <cstdlib>
#include <filesystem>
#include <fstream>
#include <iostream>

#include <opae/utils.h>

#include "AFU.h"
// Contains application-specific information
#include "config.h"
// Auto-generated by OPAE's afu_json_mgr script
#include "CardInterface.h"
#include "afu_json_info.h"

/* unneeded for now but keep in here as reference
#define CACHE_LINE_BYTES 64
#define NUM_CACHE_LINES 4096
*/

using namespace std;

unsigned long stringToPositiveNum(char* str, int radix);
void printUsage(char* name);
bool checkUsage(int argc, char* argv[], uint64_t* dataMatrixStart, uint64_t* weightsStart,
                uint64_t* resultStart, uint64_t* resultSize);
std::vector<uint32_t> readbin(const std::string& path);

int main(int argc, char* argv[]) {

// USAGE: ./afu_ase <code_filepath> <datamatrix_filepath> <assembly address to write datamatrix> 
//      <weights_filepath> <assembly address to write weights> <starting address of results> <length of results>

    std::string codeFilepath = argv[1];
    std::string dataMatrixFilepath = argv[2];
    uint64_t dataMatrixStart;
    std::string weightsFilepath = argv[4];
    uint64_t weightsStart;
    uint64_t resultStart;
    uint64_t resultSize;

    if (!checkUsage(argc, argv, &dataMatrixStart, &weightsStart, &resultStart, &resultSize)) { 
        printUsage(argv[0]);
        return EXIT_FAILURE;
    }

    try {
        // Create an AFU object to provide basic services for the FPGA. The
        // constructor searchers available FPGAs for one with an AFU with the
        // the specified ID
        AFU afu(AFU_ACCEL_UUID);
        uint8_t* cardMem;


        auto codeImage = readbin(codeFilepath);
        auto dataMatImage = readbin(dataMatrixFilepath);
        auto weightsImage = readbin(weightsFilepath);


        uint64_t totalSize = codeImage.size() + dataMatImage.size() + weightsImage.size();
        totalSize  = totalSize * 4 + resultSize;


        CardInterface iface(std::move(afu), cardMem, totalSize);
        bool failed = false;
        void* result = malloc(resultSize * 4);


        // for (unsigned test=0; test < num_tests; test++) {

        iface.copyToCard(codeImage.data(), 0x0, codeImage.size() * 4);
        iface.copyToCard(dataMatImage.data(), dataMatrixStart, dataMatImage.size() * 4);
        iface.copyToCard(weightsImage.data(), weightsStart, weightsImage.size() * 4);
        iface.sendStart();
        iface.resetCores(1);
        iface.unhaltCores(1);

        // Wait until the FPGA is done.
        while (iface.checkDirty() == 0) { 
#ifdef SLEEP_WHILE_WAITING // remove define when synthesizing
            this_thread::sleep_for(chrono::milliseconds(SLEEP_MS));
#endif
        }

        iface.haltCores(1);
        iface.copyFromCard(result, resultAddr, resultSize*4);

        std::ofstream fOut('results.txt', std::ios::trunc | std::ios::binary);
        fOut.write(reinterpret_cast<char*>(result, resultSize * 4);
        

        // Free the allocated memory.
        free(result);
        //}

        if (failed) {
            cout << "DMA tests failed." << endl;
            return EXIT_FAILURE;
        }

        cout << "All DMA Tests Successful!!!" << endl;
        return EXIT_SUCCESS;
    }
    // Exception handling for all the runtime errors that can occur within
    // the AFU wrapper class.
    catch (const fpga_result& e) {

        // Provide more meaningful error messages for each exception.
        if (e == FPGA_BUSY) {
            cerr << "ERROR: All FPGAs busy." << endl;
        } else if (e == FPGA_NOT_FOUND) {
            cerr << "ERROR: FPGA with accelerator " << AFU_ACCEL_UUID
                 << " not found." << endl;
        } else {
            // Print the default error string for the remaining fpga_result
            // types.
            cerr << "ERROR: " << fpgaErrStr(e) << endl;
        }
    } catch (const runtime_error& e) {
        cerr << e.what() << endl;
    } catch (const opae::fpga::types::no_driver& e) {
        cerr << "ERROR: No FPGA driver found." << endl;
    }

    return EXIT_FAILURE;
}

std::vector<uint32_t> readbin(const std::string& path) {
    if (!std::filesystem::is_regular_file(path)) {
        fmt::print(stderr, "[!] `{}` is not a file\n", path);
        exit(1);
    }
    std::ifstream fBin(path, std::ios::binary);
    if (!fBin.is_open()) {
        fmt::print(stderr, "[!] can't open `{}`\n", path);
        exit(1);
    }
    fBin.seekg(0, std::ios::end);
    size_t fsize = fBin.tellg();
    if (fsize % 4 != 0) {
        fmt::print(stderr,
                   "[!] loaded files must be a multiple of 4 bytes pls\n");
        std::exit(1);
    }
    std::vector<uint32_t> buf(fsize / 4);
    fBin.seekg(0);
    fBin.read(reinterpret_cast<char*>(buf.data()), fsize);

    return buf;
}


// Returns unsigned long representation of string str.
// Throws an exception if str is not a positive integer.
unsigned long stringToPositiveNum(char* str, int radix) {

    char* p;
    long num = strtol(str, &p, radix);
    if (p != 0 && *p == '\0' && num > 0) {
        return num;
    }

    throw runtime_error("String is not a positive number with base " + radix);
    return 0;
}


bool checkUsage(int argc, char* argv[], uint64_t* dataMatrixStart, uint64_t* weightsStart,
                uint64_t* resultStart, uint64_t* resultSize) {
    if (argc == 8) {
        try {
            *dataMatrixStart = stringToPositiveNum(argv[3], 16);
            *weightsStart = stringToPositiveNum(argv[5], 16);
            *resultStart = stringToPositiveNum(argv[6], 16);
            *resultSize = stringToPostiveNum(argv[7], 10);
            return true;
        } catch (const runtime_error& e) {
            return false;
        }
    } else {
        return false;
    }
}

void printUsage(char* name) {

    cout  << " USAGE: ./afu_ase <code_filepath> <datamatrix_filepath> <assembly address to write datamatrix> 
//      <weights_filepath> <assembly address to write weights> <starting address of results> <length of results>"
            "file>\n";
}

