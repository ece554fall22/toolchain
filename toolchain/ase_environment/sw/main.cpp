

#include <cmath>
#include <cstdlib>
#include <filesystem>
#include <fstream>
#include <iostream>

#include <opae/utils.h>

#include "AFU.h"
// Contains application-specific information
#include "config.h"
// Auto-generated by OPAE's afu_json_mgr script
#include "CardInterface.h"
#include "afu_json_info.h"

/* unneeded for now but keep in here as reference
#define CACHE_LINE_BYTES 64
#define NUM_CACHE_LINES 4096
*/

using namespace std;

unsigned long stringToPositiveNum(char* str, int radix);
void printUsage(char* name);
bool checkUsage(int argc, char* argv[], uint64_t* dataMatrixStart, uint64_t* weightsStart,
                uint64_t* resultStart, uint64_t* resultSize);

int main(int argc, char* argv[]) {

// USAGE: ./afu_ase <code_filepath> <datamatrix_filepath> <assembly address to write datamatrix> 
//      <weights_filepath> <assembly address to write weights> <starting address of results> <length of results>

    std::string codeFilepath = argv[1];
    std::string dataMatrixFilepath = argv[2];
    uint64_t dataMatrixStart;
    std::string weightsFilepath = argv[4];
    uint64_t weightsStart;
    uint64_t resultStart;
    uint64_t resultSize;

    if (!checkUsage(argc, argv, &dataMatrixStart, &weightsStart, &resultStart, &resultSize)) { 
        printUsage(argv[0]);
        return EXIT_FAILURE;
    }

    try {
        // Create an AFU object to provide basic services for the FPGA. The
        // constructor searchers available FPGAs for one with an AFU with the
        // the specified ID
        AFU afu(AFU_ACCEL_UUID);
        uint8_t* cardMem;


        // read code image file
        if (!std::filesystem::is_regular_file(codeFilepath)) {
            throw runtime_error("[!] " + codeFilepath + " is not a file");
        }
        std::ifstream codeBin(codeFilepath, std::ios::binary);
        if (!codeBin.is_open()) {
            throw runtime_error("[!] can't open " + codeFilepath);
        }
        codeBin.seekg(0, std::ios::end);
        size_t fsize = codeBin.tellg();
        if (fsize % 4 != 0) {
            std::cerr << "filesize should be a multiple of 4\n";
            std::exit(1);
        }
        std::vector<uint32_t> codeImage(fsize / 4);
        // WARNING WARNING TODO(erin): only works on little-endian architectures
        codeBin.seekg(0);
        codeBin.read(reinterpret_cast<char*>(codeImage.data()), fsize);


        
        // read data matrix file
        if (!std::filesystem::is_regular_file(dataMatrixFilepath)) {
            throw runtime_error("[!] " + dataMatrixFilepath + " is not a file");
        }
        std::ifstream dataMatBin(dataMatrixFilepath, std::ios::binary);
        if (!dataMatBin.is_open()) {
            throw runtime_error("[!] can't open " + dataMatrixFilepath);
        }
        dataMatBin.seekg(0, std::ios::end);
        fsize = dataMatBin.tellg();
        if (fsize % 4 != 0) {
            std::cerr << "filesize should be a multiple of 4\n";
            std::exit(1);
        }
        std::vector<uint32_t> dataMatImage(fsize / 4);
        // WARNING WARNING TODO(erin): only works on little-endian architectures
        dataMatBin.seekg(0);
        dataMatBin.read(reinterpret_cast<char*>(dataMatImage.data()), fsize);




        // read weights file
        if (!std::filesystem::is_regular_file(weightsFilepath)) {
            throw runtime_error("[!] " + weightsFilepath + " is not a file");
        }
        std::ifstream weightsBin(weightsFilepath, std::ios::binary);
        if (!weightsBin.is_open()) {
            throw runtime_error("[!] can't open " + weightsFilepath);
        }
        weightsBin.seekg(0, std::ios::end);
        fsize = weightsBin.tellg();
        if (fsize % 4 != 0) {
            std::cerr << "filesize should be a multiple of 4\n";
            std::exit(1);
        }
        std::vector<uint32_t> weightsImage(fsize / 4);
        // WARNING WARNING TODO(erin): only works on little-endian architectures
        weightsBin.seekg(0);
        weightsBin.read(reinterpret_cast<char*>(weightsImage.data()), fsize);

        uint64_t totalSize = codeImage.size() + dataMatImage.size() + weightsImage.size();
        totalSize  = totalSize * 4 + resultSize;


        CardInterface iface(std::move(afu), cardMem, totalSize);
        bool failed = false;
        void* result = malloc(resultSize);


        // for (unsigned test=0; test < num_tests; test++) {

        iface.copyToCard(codeImage.data(), 0x0, codeImage.size() * 4);
        iface.copyToCard(dataMatImage.data(), dataMatrixStart, dataMatImage.size() * 4);
        iface.copyToCard(weightsImage.data(), weightsStart, weightsImage.size() * 4);
        iface.sendStart();
        iface.resetCores(1);
        iface.unhaltCores(1);

        // Wait until the FPGA is done.
        while (iface.checkDirty() == 0) {
#ifdef SLEEP_WHILE_WAITING
            this_thread::sleep_for(chrono::milliseconds(SLEEP_MS));
#endif
        }

        iface.haltCores(1);
        iface.copyFromCard(result, resultAddr, resultSize);

        // TODO output results to file????

        // Free the allocated memory.
        free(result);
        //}

        if (failed) {
            cout << "DMA tests failed." << endl;
            return EXIT_FAILURE;
        }

        cout << "All DMA Tests Successful!!!" << endl;
        return EXIT_SUCCESS;
    }
    // Exception handling for all the runtime errors that can occur within
    // the AFU wrapper class.
    catch (const fpga_result& e) {

        // Provide more meaningful error messages for each exception.
        if (e == FPGA_BUSY) {
            cerr << "ERROR: All FPGAs busy." << endl;
        } else if (e == FPGA_NOT_FOUND) {
            cerr << "ERROR: FPGA with accelerator " << AFU_ACCEL_UUID
                 << " not found." << endl;
        } else {
            // Print the default error string for the remaining fpga_result
            // types.
            cerr << "ERROR: " << fpgaErrStr(e) << endl;
        }
    } catch (const runtime_error& e) {
        cerr << e.what() << endl;
    } catch (const opae::fpga::types::no_driver& e) {
        cerr << "ERROR: No FPGA driver found." << endl;
    }

    return EXIT_FAILURE;
}

// Returns unsigned long representation of string str.
// Throws an exception if str is not a positive integer.
unsigned long stringToPositiveNum(char* str, int radix) {

    char* p;
    long num = strtol(str, &p, radix);
    if (p != 0 && *p == '\0' && num > 0) {
        return num;
    }

    throw runtime_error("String is not a positive number with base " + radix);
    return 0;
}


bool checkUsage(int argc, char* argv[], uint64_t* dataMatrixStart, uint64_t* weightsStart,
                uint64_t* resultStart, uint64_t* resultSize) {
    if (argc == 8) {
        try {
            *dataMatrixStart = stringToPositiveNum(argv[3], 16);
            *weightsStart = stringToPositiveNum(argv[5], 16);
            *resultStart = stringToPositiveNum(argv[6], 16);
            *resultSize = stringToPostiveNum(argv[7], 10);
            return true;
        } catch (const runtime_error& e) {
            return false;
        }
    } else {
        return false;
    }
}

void printUsage(char* name) {

    cout  << " USAGE: ./afu_ase <code_filepath> <datamatrix_filepath> <assembly address to write datamatrix> 
//      <weights_filepath> <assembly address to write weights> <starting address of results> <length of results>"
            "file>\n";
}

