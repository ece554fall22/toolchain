

#include <filesystem>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <cmath>

#include <opae/utils.h>

#include "AFU.h"
// Contains application-specific information
#include "config.h"
// Auto-generated by OPAE's afu_json_mgr script
#include "afu_json_info.h"
#include "CardInterface.h"

/* unneeded for now but keep in here as reference
#define CACHE_LINE_BYTES 64
#define NUM_CACHE_LINES 4096
*/

using namespace std;

unsigned long stringToPositiveInt(char *str);
void printUsage(char *name); 
bool checkUsage(int argc, char* argv[]);


int main(int argc, char *argv[]) {

  if (!checkUsage(argc, argv)) { // TODO check usage for new inputs
    printUsage(argv[0]);
    return EXIT_FAILURE;
  }

 

  try {
    // Create an AFU object to provide basic services for the FPGA. The 
    // constructor searchers available FPGAs for one with an AFU with the
    // the specified ID
    AFU afu(AFU_ACCEL_UUID); 
    uint8_t* cardMem;
    CardInterface iface(std::move(afu), cardMem);

    bool failed = false;
    uint64_t resultAddr = 0; // TODO enter this when starting program
    uint64_t resultSize = 0; // TODO enter this when starting program (in number of bytes)
    void* result = malloc(resultSize);

    std::string path = argv[1];
    if (!std::filesystem::is_regular_file(path)) {
        throw runtime_error("[!] "+ path +  " is not a file");
    }
    std::ifstream fBin(path, std::ios::binary);
    if (!fBin.is_open()) {
        throw runtime_error("[!] can't open "+ path);
    }
    fBin.seekg(0, std::ios::end);
    size_t fsize = fBin.tellg();
    if (fsize % 4 != 0) {
	    std::cerr << "filesize should be a multiple of 4\n";
	    std::exit(1);
    }
    std::vector<uint32_t> codeImage(fsize/4);
    // WARNING WARNING TODO(erin): only works on little-endian architectures
    fBin.seekg(0);
    fBin.read(reinterpret_cast<char*>(codeImage.data()), fsize);


    //for (unsigned test=0; test < num_tests; test++) {
 
      iface.copyToCard(codeImage.data(), 0x0, codeImage.size()*4);
      iface.sendStart();
      iface.resetCores(1);
      iface.unhaltCores(1);

      // Wait until the FPGA is done.
      while (iface.checkDirty() == 0) {
#ifdef SLEEP_WHILE_WAITING
	this_thread::sleep_for(chrono::milliseconds(SLEEP_MS));
#endif
      }
        
      iface.haltCores(1);
      iface.copyFromCard(result, resultAddr, resultSize);

      // TODO output results to file????
    
      // Free the allocated memory.
      free(result);
    //} 

    if (failed) {
      cout << "DMA tests failed." << endl;
      return EXIT_FAILURE;
    }

    cout << "All DMA Tests Successful!!!" << endl;
    return EXIT_SUCCESS;
  }
  // Exception handling for all the runtime errors that can occur within 
  // the AFU wrapper class.
  catch (const fpga_result& e) {    
    
    // Provide more meaningful error messages for each exception.
    if (e == FPGA_BUSY) {
      cerr << "ERROR: All FPGAs busy." << endl;
    }
    else if (e == FPGA_NOT_FOUND) { 
      cerr << "ERROR: FPGA with accelerator " << AFU_ACCEL_UUID 
	   << " not found." << endl;
    }
    else {
      // Print the default error string for the remaining fpga_result types.
      cerr << "ERROR: " << fpgaErrStr(e) << endl;    
    }
  }
  catch (const runtime_error& e) {    
    cerr << e.what() << endl;
  }
  catch (const opae::fpga::types::no_driver& e) {
    cerr << "ERROR: No FPGA driver found." << endl;
  }

  return EXIT_FAILURE;
}


// Returns unsigned long representation of string str.
// Throws an exception if str is not a positive integer.
unsigned long stringToPositiveInt(char *str) {

  char *p;
  long num = strtol(str, &p, 10);  
  if (p != 0 && *p == '\0' && num > 0) {
    return num;
  }

  throw runtime_error("String is not a positive integer.");
  return 0;  
}

bool checkUsage(int argc, char* argv[]) { // could use some work
    if (argc == 3) {
    try {
      stringToPositiveInt(argv[2]);
      return true;
    }
    catch (const runtime_error& e) {    
      return false;
    }
  }
  else {
    return false;
  }
}

void printUsage(char *name) {

  cout << "Usage: " << name << " <filename of binary mem file> <number of bytes in binary mem file>\n";
}
